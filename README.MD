
I tried to do day 1 on my [Spectrum Next](https://en.wikipedia.org/wiki/ZX_Spectrum_Next) using 48K [Sinclair Basic](https://en.wikipedia.org/wiki/Sinclair_BASIC). Before I realized that we had a much larger input file, I started writing the code for the given demo input by giving the input prompts for every integer. It was a very straightforward code. Grab input, bubble sort both arrays, get distances and add them up. On Spectrum, basic commands are actually on the keys, you don't type them out. I was surprised how well laid out they were. It was still very slow going. For every change I had to retype lines since there's no fancy shmancy IDE, everything is just numbered line based.

At some point I realized that my input is actually massive and that I wouldn't be able to type that in. That changed everything. Now I had to deal with a massive input using very limited memory on an 48K 8bit computer that uses tape as a storage mechanism. In Basic, I was just using `DIM(100)` as a buffer for my array but since input was so much larger I had to rethink what I can do. I could still use two large buffer arrays that fit in memory or I can go dynamic and use `POKE/PEEK` to create dynamic arrays directly in memory. I am not sure which way is more performant. I'd have to test. Because we have two arrays it would make sense to map them in the interleaved manner and move through them by skipping two bytes. That's another thing, now we have 16bit math on an 8bit machine. Thankfully, Z80 can actually do that using pairs of registers. Does Basic use those registers? Not sure. Now I needed a way to somehow input all of that data. I forgot that I had a choice to actually grab my tape deck and use the tape so I was trying to figure out what I could do on the machine's SD card. I was just trying to use `SAVE/LOAD` of arrays to see how that would work. I found some firmware that would emulate SD card hardware that emulates Tape hardware :) for the Next but after a while of struggling I still could not save the array. At this point I spent a ton of time on day 1 problem so I figured that I need to start cutting my losses (I didn't even realize that there was part 2 to day 1). I had to put my Spectrum down and do the boring thing :(

I wanted to just wrap this up so back to VM/JS. The code was done quickly and then I saw that there was part 2 so that was also done in JS. Some of the things that I had to think about -
Should I load the whole file or parse line by line? How big can this file actually get? Should I memory map the whole file? In the end, I just loaded the file and parsed it.
Another question was about performance of reduce vs a simple loop. I assumed that a loop is more performant so I used that.
In part 2 the only new question was what to use in place of a dictionary. Between objects and maps I think maps would be more performant (at least at larger sizes) so I used that.
I was out of time but it felt so unsatisfying having solved the problem in the most straightforward way. I wanted to do just one more thing so I figured a couple of [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck) property tests would at least add something interesting. Had to google JS quickcheck and [fast-check](https://github.com/dubzzz/fast-check) was first so I read the docs for that. JS syntax is total jank so it took me a moment to get things right. The interesting part there is thinking about the properties of our solution. I came up with these - the output is supposed to be a non-negative integer, it's supposed  to give us the shortest possible distance because of sorting, and the two input lists should be able to be reversed without affecting the output. I didn't have time to do this for part 2.

After all of this, the insight for me was how far we've come. It's trivial to solve this advent problem nowadays. It's trivial to grab data off the internet and copy its content to a file on my system. The size of that file can be massive. I barely have to think about memory implications. I don't have to overthink optimally structuring my data. Performance will likely be fast enough. I can edit my application as a whole with a tool like VIM. I can pick any language I want. I can trivially write some tests. Things are so easy! The problems we are able to solve and the time it takes us to solve them are just so staggeringly different from a few decades ago. We can truly concentrate on the problem and not on the limitations of our problem solving apparatus. The problems that we do create for ourselves (languages, editors, OSes, etc) are hilarious compared to the past. Everything we have is so incredibly powerful and yet we are never happy and keep seeking something better.
